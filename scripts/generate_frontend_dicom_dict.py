# backend/scripts/generate_frontend_dicom_dict.py
import json
import os
from pydicom.datadict import keyword_for_tag # Use keyword_for_tag for consistency
from pydicom._dicom_dict import DicomDictionary

# --- Configuration ---
# Adjust the output path as needed relative to where you run the script
# Assuming you run it from the 'backend' directory:
DEFAULT_OUTPUT_PATH = "../frontend/src/dicom/dictionary.ts"

def generate_dicom_dictionary_ts(output_path: str = DEFAULT_OUTPUT_PATH):
    """
    Generates a TypeScript file containing the DICOM dictionary
    in the format expected by frontend/src/dicom/dictionary.ts.
    """
    output_list = []
    processed_keywords = set() # To keep track of keywords and ensure primary entries are unique by keyword

    # DicomDictionary from pydicom is {tag_int: (VR, VM, Name, Retired, Keyword), ...}
    # We iterate and then sort to ensure a consistent order, by keyword primarily.

    temp_list_for_sorting = []

    for tag_val, entry_details in DicomDictionary.items():
        # entry_details is a tuple: (VR, VM, Name, Retired, Keyword)
        # Ensure the entry_details has enough elements (especially for Keyword)
        if len(entry_details) < 5 or not entry_details[4]: # Skip if no keyword
            # print(f"Skipping tag {tag_val:08X} due to missing keyword in pydicom's DicomDictionary entry: {entry_details}")
            continue

        keyword = entry_details[4]
        tag_group = tag_val >> 16
        tag_element = tag_val & 0xFFFF
        
        # Format tag as "GGGG,EEEE" (uppercase hex)
        tag_str_formatted = f"{tag_group:04X},{tag_element:04X}"
        
        vr = entry_details[0]
        name = entry_details[2] # This is the 'Name' or description of the tag

        temp_list_for_sorting.append({
            "tag": tag_str_formatted,
            "name": name,
            "vr": vr,
            "keyword": keyword,
        })

    # Sort by keyword for a clean, predictable order in the generated file
    temp_list_for_sorting.sort(key=lambda x: x["keyword"])

    # Now, populate the final output list, ensuring unique keywords are primary
    # (This sorting handles the uniqueness implicitly if keywords are unique in DicomDictionary,
    # which they should be for standard tags)
    output_list = temp_list_for_sorting

    # Construct the TypeScript file content
    ts_content = f"""// src/dicom/dictionary.ts
// GENERATED BY backend/scripts/generate_frontend_dicom_dict.py - DO NOT EDIT MANUALLY!
// Last generated: {__import__('datetime').datetime.now().isoformat()}

export interface DicomTagInfo {{
    tag: string; // Format: "GGGG,EEEE" e.g., "0010,0010"
    name: string;
    vr: string;
    keyword: string;
}}

export const dicomDictionary: DicomTagInfo[] = {json.dumps(output_list, indent=4)};

// Helper function to find tag info by tag number (or keyword/name later)
// This version prioritizes exact match on keyword or normalized tag.
export const getTagInfo = (tagOrKeyword: string): DicomTagInfo | undefined => {{
    const query = String(tagOrKeyword).trim().toUpperCase();
    
    // Attempt direct keyword match first
    let found = dicomDictionary.find(entry => entry.keyword.toUpperCase() === query);
    if (found) return found;

    // Attempt direct tag match (GGGG,EEEE format)
    const tagPattern = /^([0-9A-F]{{4}}),([0-9A-F]{{4}})$/;
    const tagMatch = query.match(tagPattern);
    if (tagMatch) {{
        const formattedQueryTag = `${{tagMatch[1]}},${{tagMatch[2]}}`; // Ensure consistent format
        found = dicomDictionary.find(entry => entry.tag === formattedQueryTag);
        if (found) return found;
    }}
    
    // Attempt to match if query is GGGGEEEE
    const compactTagPattern = /^[0-9A-F]{{8}}$/;
    if (compactTagPattern.test(query)) {{
        const formattedCompactQueryTag = `${{query.substring(0, 4)}},${{query.substring(4, 8)}}`;
        found = dicomDictionary.find(entry => entry.tag === formattedCompactQueryTag);
        if (found) return found;
    }}

    return undefined;
}};

// Helper to find tags matching a query (name, keyword, or tag number)
export const findMatchingTags = (query: string): DicomTagInfo[] => {{
    if (!query || String(query).trim() === "") {{
        return [];
    }}
    const lowerCaseQuery = String(query).toLowerCase().trim();
    const MAX_RESULTS = 20; // Increased limit slightly

    return dicomDictionary.filter(entry =>
        entry.name.toLowerCase().includes(lowerCaseQuery) ||
        entry.keyword.toLowerCase().includes(lowerCaseQuery) ||
        entry.tag.toLowerCase().includes(lowerCaseQuery) 
    ).slice(0, MAX_RESULTS); 
}};
"""

    # Ensure the output directory exists
    output_dir = os.path.dirname(os.path.abspath(output_path))
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)
        print(f"Created directory: {output_dir}")

    try:
        with open(output_path, "w", encoding="utf-8") as f:
            f.write(ts_content)
        print(f"Successfully generated DICOM dictionary at: {output_path}")
        print(f"Total tags written: {len(output_list)}")
    except IOError as e:
        print(f"Error writing to file {output_path}: {e}")

if __name__ == "__main__":
    # Example: Run from 'backend' directory, script is in 'backend/scripts/'
    # To make path relative to script location:
    # script_dir = os.path.dirname(os.path.abspath(__file__))
    # output_file_path = os.path.join(script_dir, "../../frontend/src/dicom/dictionary.ts")
    # generate_dicom_dictionary_ts(output_file_path)
    
    # If running from project root, you might adjust or use absolute path
    # For now, using the default path assuming execution from `backend/`
    generate_dicom_dictionary_ts()
