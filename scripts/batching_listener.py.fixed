#!/usr/bin/env python

import os
import sys
import time
import subprocess
import threading
from collections import defaultdict, deque
from pathlib import Path
import logging

# Add the project root to the Python path
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

# Database imports
from sqlalchemy.exc import SQLAlchemyError
from app.db.session import SessionLocal
from app.crud import crud_dimse_listener_state, crud_dimse_listener_config

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - [AssociationBatcher] - %(message)s')

DICOM_DIR = "/dicom_data/incoming"
BATCH_TIMEOUT = 5.0  # Wait 5 seconds after the last file before processing the batch
PROCESS_ASSOCIATION_SCRIPT = "/app/scripts/process_association.py"
HEARTBEAT_INTERVAL = 30  # Send heartbeat every 30 seconds
LISTENER_INSTANCE_ID = os.getenv("AXIOM_INSTANCE_ID", "dcm4che_1")

class HeartbeatManager:
    """Manages heartbeat and status reporting for the dcm4che listener."""
    
    def __init__(self, listener_id: str):
        self.listener_id = listener_id
        self.listener_config = None
        self.last_heartbeat = time.time()
        self.heartbeat_thread = None
        self.running = False
    
    def _load_listener_config(self):
        """Load the listener configuration from the database."""
        try:
            db = SessionLocal()
            config = crud_dimse_listener_config.get_by_instance_id(db=db, instance_id=self.listener_id)
            if config:
                self.listener_config = config
                logging.info(f"Loaded config for listener '{config.name}' (AE: {config.ae_title})")
            else:
                logging.error(f"No config found for listener instance: {self.listener_id}")
        except Exception as e:
            logging.error(f"Failed to load listener config: {e}")
        finally:
            if 'db' in locals():
                db.close()
    
    def _update_status(self, status: str, message: str = None):
        """Update listener status in database."""
        try:
            db = SessionLocal()
            crud_dimse_listener_state.update_or_create_listener_state(
                db=db,
                listener_id=self.listener_id,
                status=status,
                status_message=message,
                host="0.0.0.0",
                port=11114,
                ae_title="DCM4CHE"
            )
            db.commit()
        except Exception as e:
            logging.error(f"Failed to update status: {e}")
            if 'db' in locals():
                db.rollback()
        finally:
            if 'db' in locals():
                db.close()
    
    def _send_heartbeat(self):
        """Send heartbeat to database."""
        try:
            db = SessionLocal()
            crud_dimse_listener_state.update_listener_heartbeat(db=db, listener_id=self.listener_id)
            db.commit()
            logging.debug("Heartbeat sent successfully")
        except Exception as e:
            logging.error(f"Failed to send heartbeat: {e}")
            if 'db' in locals():
                db.rollback()
        finally:
            if 'db' in locals():
                db.close()
    
    def _heartbeat_loop(self):
        """Main heartbeat loop running in background thread."""
        logging.info(f"Starting heartbeat loop (interval: {HEARTBEAT_INTERVAL}s)")
        while self.running:
            try:
                self._send_heartbeat()
                self.last_heartbeat = time.time()
            except Exception as e:
                logging.error(f"Error in heartbeat loop: {e}")
            
            # Sleep in small intervals to allow for quick shutdown
            for _ in range(HEARTBEAT_INTERVAL * 10):  # 0.1s intervals
                if not self.running:
                    break
                time.sleep(0.1)
    
    def start(self):
        """Start the heartbeat manager."""
        self._load_listener_config()
        self._update_status("starting", "DCM4CHE listener starting up")
        self.running = True
        self.heartbeat_thread = threading.Thread(target=self._heartbeat_loop, daemon=True)
        self.heartbeat_thread.start()
        self._update_status("running", "DCM4CHE listener active and monitoring")
        logging.info("Heartbeat manager started")
    
    def stop(self):
        """Stop the heartbeat manager."""
        logging.info("Stopping heartbeat manager")
        self.running = False
        if self.heartbeat_thread and self.heartbeat_thread.is_alive():
            self.heartbeat_thread.join(timeout=2.0)
        self._update_status("stopped", "DCM4CHE listener stopped")

class AssociationBatcher:
    """Handles batching of incoming DICOM files for processing."""
    
    def __init__(self, listener_id: str):
        self.listener_id = listener_id
        self.file_queue = set()  # Use set to avoid duplicates
        self.last_file_time = None
        self.lock = threading.Lock()
        self.running = True
    
    def add_file(self, filepath):
        """Add a file to the current batch."""
        with self.lock:
            if filepath not in self.file_queue:
                self.file_queue.add(filepath)
                self.last_file_time = time.time()
                logging.info(f"Added file to batch: {filepath} (batch size: {len(self.file_queue)})")
                
                # Update received count in database
                try:
                    db = SessionLocal()
                    crud_dimse_listener_state.increment_received_count(db=db, listener_id=self.listener_id, count=1)
                except Exception as e:
                    logging.error(f"Failed to update received count: {e}")
                finally:
                    if 'db' in locals():
                        db.close()
    
    def process_batch_if_ready(self):
        """Process the current batch if enough time has passed since the last file."""
        with self.lock:
            if not self.file_queue:
                return
                
            if self.last_file_time and (time.time() - self.last_file_time) >= BATCH_TIMEOUT:
                files_to_process = list(self.file_queue)
                self.file_queue.clear()
                logging.info(f"Processing batch of {len(files_to_process)} files")
                
                try:
                    # Call our process_association.py script with all the files
                    cmd = [PROCESS_ASSOCIATION_SCRIPT] + files_to_process
                    subprocess.run(cmd, check=True)
                    logging.info(f"Successfully processed batch of {len(files_to_process)} files")
                    
                    # Update processed count in database
                    try:
                        db = SessionLocal()
                        crud_dimse_listener_state.increment_processed_count(db=db, listener_id=self.listener_id, count=len(files_to_process))
                    except Exception as e:
                        logging.error(f"Failed to update processed count: {e}")
                    finally:
                        if 'db' in locals():
                            db.close()
                            
                except subprocess.CalledProcessError as e:
                    logging.error(f"Error processing batch: {e}")
                except Exception as e:
                    logging.error(f"Unexpected error processing batch: {e}")
    
    def monitor_loop(self):
        """Continuously monitor for batches that are ready to process."""
        while self.running:
            try:
                self.process_batch_if_ready()
                time.sleep(1.0)  # Check every second
            except Exception as e:
                logging.error(f"Error in monitor loop: {e}")
                time.sleep(1.0)
    
    def stop(self):
        """Stop the monitoring loop."""
        self.running = False

def monitor_directory():
    """Monitor the DICOM directory for new files."""
    batcher = AssociationBatcher(LISTENER_INSTANCE_ID)
    
    # Start the batch processing monitor in a separate thread
    monitor_thread = threading.Thread(target=batcher.monitor_loop, daemon=True)
    monitor_thread.start()
    
    logging.info(f"Starting to monitor directory: {DICOM_DIR}")
    
    # Keep track of files we've already seen
    known_files = set()
    
    try:
        while True:
            try:
                # List all .dcm files in the directory
                dicom_dir_path = Path(DICOM_DIR)
                current_files = set(dicom_dir_path.glob("*.dcm"))
                
                # Find new files
                new_files = current_files - known_files
                
                for file_path in new_files:
                    if file_path.is_file():
                        batcher.add_file(str(file_path))
                        known_files.add(file_path)
                
                time.sleep(0.5)  # Check every 0.5 seconds
            except Exception as e:
                logging.error(f"Error monitoring directory: {e}")
                time.sleep(1.0)
                
    except KeyboardInterrupt:
        logging.info("Received interrupt signal, stopping...")
    finally:
        batcher.stop()

# The storescp process is now managed by Docker directly
# This script only handles heartbeat and file monitoring

def main():
    """Main entry point."""
    logging.info("Starting dcm4che listener with association batching and heartbeat")
    
    heartbeat_manager = None
    
    try:
        # Initialize heartbeat manager
        heartbeat_manager = HeartbeatManager(LISTENER_INSTANCE_ID)
        
        # Start heartbeat reporting
        heartbeat_manager.start()
        
        # Note: storescp is started by Docker, we only handle file monitoring
        logging.info("Heartbeat started, beginning directory monitoring")
        
        # Start monitoring the directory for incoming files
        monitor_directory()
        
    except KeyboardInterrupt:
        logging.info("Received interrupt, shutting down...")
    except Exception as e:
        logging.error(f"Fatal error: {e}")
        if heartbeat_manager:
            heartbeat_manager._update_status("error", f"Fatal error: {str(e)}")
        return 1
    finally:
        # Clean up heartbeat manager
        if heartbeat_manager:
            heartbeat_manager.stop()
            
        logging.info("Shutdown complete")
        
    return 0

if __name__ == "__main__":
    sys.exit(main())
